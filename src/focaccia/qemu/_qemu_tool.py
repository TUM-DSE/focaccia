"""Invocable like this:

    gdb -n --batch -x qemu_tool.py

But please use `tools/validate_qemu.py` instead because we have some more setup
work to do.
"""

import logging
import traceback
import pyroaring
import subprocess
import time
from typing import Iterable, Optional

import focaccia.parser as parser
from focaccia.compare import compare_symbolic, Error, ErrorTypes
from focaccia.snapshot import (
    ProgramState,
    ReadableProgramState,
    RegisterAccessError,
    MemoryAccessError,
)
from focaccia.symbolic import SymbolicTransform, eval_symbol, ExprMem
from focaccia.trace import Trace, TraceContainer, TraceEnvironment
from focaccia.utils import print_result
from focaccia.deterministic import DeterministicLog, Event

from focaccia.tools.validate_qemu import make_argparser, verbosity
from focaccia.qemu.target import GDBProgramState, GDBServerStateIterator

logger = logging.getLogger('focaccia-qemu-validator')
debug = logger.debug
info = logger.info
warn = logger.warning

qemu_crash = {
        "crashed": False,
        "pc": None,
        'txl': None,
        'ref': None,
        'errors': [Error(ErrorTypes.CONFIRMED, "QEMU crashed")],
        'snap': None,
}

def record_minimal_snapshot(prev_state: ReadableProgramState,
                            cur_state: ReadableProgramState,
                            prev_transform: SymbolicTransform,
                            cur_transform: SymbolicTransform) \
        -> ProgramState:
    """Record a minimal snapshot.

    A minimal snapshot must include values (registers and memory) that are
    accessed by two transformations:
      1. The values produced by the previous transformation (the
         transformation that is producing this snapshot) to check these
         values against expected values calculated from the previous
         program state.
      2. The values that act as inputs to the transformation acting on this
         snapshot, to calculate the expected values of the next snapshot.

    :param prev_transform: The symbolic transformation generating, or
                           leading to, `cur_state`. Values generated by
                           this transformation are included in the
                           snapshot.
    :param transform: The symbolic transformation operating on this
                      snapshot. Input values to this transformation are
                      included in the snapshot.
    """
    assert(cur_state.read_pc() == cur_transform.addr)
    assert(prev_transform.arch == cur_transform.arch)

    def get_written_addresses(t: SymbolicTransform):
        """Get all output memory accesses of a symbolic transformation."""
        return [ExprMem(a, v.size) for a, v in t.changed_mem.items()]

    def set_values(regs: Iterable[str], mems: Iterable[ExprMem],
                   cur_state: ReadableProgramState,
                   prev_state: ReadableProgramState,
                   out_state: ProgramState):
        """
        :param prev_state: Addresses of memory included in the snapshot are
                           resolved relative to this state.
        """
        for regname in regs:
            try:
                regval = cur_state.read_register(regname)
                out_state.write_register(regname, regval)
            except RegisterAccessError:
                pass
        for mem in mems:
            assert(mem.size % 8 == 0)
            addr = eval_symbol(mem.ptr, prev_state)
            try:
                mem = cur_state.read_memory(addr, int(mem.size / 8))
                out_state.write_memory(addr, mem)
            except MemoryAccessError:
                pass

    state = ProgramState(cur_transform.arch)
    state.write_register('PC', cur_transform.addr)

    set_values(prev_transform.changed_regs.keys(),
               get_written_addresses(prev_transform),
               cur_state,
               prev_state,  # Evaluate memory addresses based on previous
                            # state because they are that state's output
                            # addresses.
               state)
    set_values(cur_transform.get_used_registers(),
               cur_transform.get_used_memory_addresses(),
               cur_state,
               cur_state,
               state)
    return state

def collect_conc_trace(gdb: GDBServerStateIterator, strace: Trace) \
        -> tuple[list[ProgramState], list[SymbolicTransform]]:
    """Collect a trace of concrete states from GDB.

    Records minimal concrete states from GDB by using symbolic trace
    information to determine which register/memory values are required to
    verify the correctness of the program running in GDB.

    May drop symbolic transformations if the symbolic trace and the GDB trace
    diverge (e.g. because of differences in environment, etc.). Returns the
    new, possibly modified, symbolic trace that matches the returned concrete
    trace.

    :return: A list of concrete states and a list of corresponding symbolic
             transformations. The lists are guaranteed to have the same length.
    """
    def find_index(seq, target):
        for i, el in enumerate(seq):
            if el == target:
                return i
        return None

    if not strace:
        return [], []

    states = []
    matched_transforms = []

    state_iter = iter(gdb)
    cur_state = next(state_iter)
    symb_i = 0

    trace = iter(strace)

    if logger.isEnabledFor(logging.DEBUG):
        debug('Tracing program with the following non-deterministic events:')
        for event in gdb._events.events:
            debug(event)

    # Skip to start
    pc = cur_state.read_pc()
    start_addr = strace.env.start_address if strace.env.start_address else pc
    try:
        if pc != start_addr:
            info(f'Executing until starting address {hex(start_addr)}')
            cur_state = state_iter.run_until(start_addr)
    except Exception as e:
        if pc != start_addr:
            raise Exception(f'Unable to reach start address {hex(start_addr)}: {e}')
        raise Exception(f'Unable to trace: {e}')

    # An online trace matching algorithm.
    info(f'Tracing QEMU between {hex(start_addr)}:{hex(strace.env.stop_address) if strace.env.stop_address else "end"}')
    traced_address_set = pyroaring.BitMap64(strace.addresses)

    transform: Optional[SymbolicTransform] = None
    while True:
        try:
            pc = cur_state.read_pc()
            if strace.env.stop_address and pc == strace.env.stop_address:
                break

            try:
                transform = next(trace)
            except StopIteration:
                break

            while pc != transform.addr:
                warn(f'PC {hex(pc)} does not match next symbolic reference {hex(transform.addr)}')

                next_i = None
                if pc in traced_address_set:
                    next_i = find_index(strace.addresses[symb_i+1:], pc)
                    print(f'Next {next_i}, current {symb_i}')

                # Drop the concrete state if no address in the symbolic trace
                # matches
                if next_i is None:
                    warn(f'Dropping concrete state {hex(pc)}, as no'
                         f' matching instruction can be found in the symbolic'
                         f' reference trace.')
                    cur_state = next(state_iter)
                    pc = cur_state.read_pc()
                    continue

                # Otherwise, jump to the next matching symbolic state
                try:
                    trace.skip(next_i)
                    transform = next(trace)
                    symb_i += next_i+1
                except StopIteration:
                    warn(f'QEMU executed more states than native execution: {symb_i} vs {len(strace.addresses)-1}')
                    break

            assert(cur_state.read_pc() == transform.addr)
            info(f'Validating instruction at address {hex(pc)}')
            states.append(record_minimal_snapshot(
                states[-1] if states else cur_state,
                cur_state,
                matched_transforms[-1] if matched_transforms else transform,
                transform))
            symb_i += 1
            matched_transforms.append(transform)
            cur_state = next(state_iter)
        except StopIteration:
            # TODO: The conditions may test for the same
            if strace.env.stop_address and pc != strace.env.stop_address:
                raise Exception(f'QEMU stopped at {hex(pc)} before reaching the stop address'
                                f' {hex(strace.env.stop_address)}')

            assert(transform is not None)
            if symb_i+1 < len(strace.addresses):
                qemu_crash["crashed"] = True
                qemu_crash["pc"] = transform.addr
                qemu_crash["ref"] = transform
                qemu_crash["snap"] = states[-1]
            break
        except Exception as e:
            print(traceback.format_exc())
            raise e

    return states, matched_transforms

def main():
    args = make_argparser().parse_args()

    logging_level = getattr(logging, args.error_level.upper(), logging.INFO)
    logging.basicConfig(level=logging_level, force=True)

    detlog = DeterministicLog(args.deterministic_log)
    if args.deterministic_log and detlog.base_directory is None:
        raise NotImplementedError(f'Deterministic log {args.deterministic_log} specified but '
                                   'Focaccia built without deterministic log support')

    try:
        gdb_server = GDBServerStateIterator(args.remote, detlog)
    except Exception as e:
        raise Exception(f'Unable to perform basic GDB setup: {e}')

    try:
        executable: str | None = None
        if args.executable is None:
            executable = gdb_server.binary
        else:
            executable = args.executable

        argv = []  # QEMU's GDB stub does not support 'info proc cmdline'
        envp = []  # Can't get the remote target's environment
        env = TraceEnvironment(executable, argv, envp, '?')
    except Exception as e:
        raise Exception(f'Unable to create trace environment for executable {executable}: {e}')

    # Read pre-computed symbolic trace
    try:
        if args.trace_type == 'json':
            file = open(args.symb_trace, 'r')
            symb_transforms = parser.parse_transformations(file)
        else:
            file = open(args.symb_trace, 'rb')
            symb_transforms = parser.stream_transformation(file)
    except Exception as e:
        raise Exception(f'Failed to parse state transformations from native trace: {e}')

    # Use symbolic trace to collect concrete trace from QEMU
    try:
        conc_states, matched_transforms = collect_conc_trace(
            gdb_server,
            symb_transforms.states,
            symb_transforms.env.start_address,
            symb_transforms.env.stop_address)
    except Exception as e:
        raise Exception(f'Failed to collect concolic trace from QEMU: {e}')

    # Verify and print result
    if not args.quiet:
        try:
            res = compare_symbolic(conc_states, matched_transforms)
            if qemu_crash["crashed"]:
                res.append({
                    'pc': qemu_crash["pc"],
                    'txl': None,
                    'ref': qemu_crash["ref"],
                    'errors': qemu_crash["errors"],
                    'snap': qemu_crash["snap"],
                })
            print_result(res, verbosity[args.error_level])
        except Exception as e:
            raise Exception('Error occured when comparing with symbolic equations: {e}')

    if args.output:
        from focaccia.parser import serialize_snapshots
        try:
            with open(args.output, 'w') as file:
                serialize_snapshots(Trace(conc_states, env), file)
        except Exception as e:
            raise Exception(f'Unable to serialize snapshots to file {args.output}: {e}')

if __name__ == "__main__":
    main()

